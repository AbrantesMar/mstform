* verify we cannot do fromEvent for non-string raw
  values.

* required should start working with non-string raw values, if they're maybe.

* a Group concept that aggregates validation values. Should deliver true or
  false.

* implement show error after blur, show error after pause.

* maybefy doesn't seem to be the way to go. Can we instead
  create a no-read mode that:

  * doesn't ever read underlying value from the form. Instead it displays
    an empty value defined by the converter. Any placeholder value
    (such as 0) in the mst object is ignored.

  * only upon first write tries to save the value to the underlying field.

  This needs to work for both whole forms (add form use case) as well
  as repeating items on a form.

  A field that has never been written should be considered invalid
  for the purposes of form submission.

  In case of repeating forms, we should be able to get repeating forms
  that do not save yet. We can add as many as we like. Underneath it
  adds a placeholder object.

* Further thoughts about an add mode.

  An add mode makes it so that the form is displayed with the default
  values stored in the converter, not the values from the edit state.
  As soon as a raw exists, we can track that and we're fine. This happens
  for all required fields. For non-required fields, we can just use the
  underlying value. For edit forms, we want any user-added repeating
  form entries to be in add mode. In add forms, we can assume that
  all repeating form entries that are already present are in add mode.

* a context/env system. We want custom context and the env from MST.

* converters should have access to the context. This way we can declare
  systemwide policy for converters.

* we want to selectively enable and disable, as well as make them
  visible and invisible, based on external information. Potentially
  we also want display-only.

  disabled state can be passed into input field.

  invisible is trickier: form.item doesn't support it. we could make our own
  item that accepts a hidden. Or we could create another component that takes
  care of hidden (and display-only)

  Essentially there is meta information in the form that can affect
  the field properties we generate. We want to be able to inject a way
  to generate these extra properties. The context can be the source of
  information about what to generate.
